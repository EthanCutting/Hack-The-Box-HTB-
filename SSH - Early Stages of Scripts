#1ï¸âƒ£ Install SSH Server
sudo apt update
sudo apt install openssh-server -y
# 2ï¸âƒ£ Start SSH
sudo systemctl start ssh
sudo systemctl enable ssh
# 3ï¸âƒ£ Verify
sudo systemctl status ssh
# 4ï¸âƒ£ Create Test Users
sudo adduser testuser
sudo adduser adminuser
# 5ï¸âƒ£ Check SSH Logs
sudo tail -f /var/log/auth.log

--------------------------------------------------------------------------------------------------------------------------------------------------


# ðŸ§  Phase 3: ANALYZE LOGS WITH PYTHON
#!/usr/bin/env python3
import re
import csv
import sys

LOG_FILE = "ssh_lab_logs.txt"
ALERT_THRESHOLD = 5

# IP like 192.168.1.10
IP_PATTERN = re.compile(r"\b\d{1,3}(?:\.\d{1,3}){3}\b")

# Handles both:
# "Failed password for admin from ..."
# "Failed password for invalid user admin from ..."
USER_PATTERN = re.compile(r"Failed password for (?:invalid user )?([a-zA-Z0-9._-]+)")

def load_lines(path: str) -> list[str]:
    try:
        with open(path, "r", encoding="utf-8", errors="replace") as f:
            return f.readlines()
    except FileNotFoundError:
        print(f"[!] Log file not found: {path}")
        print("[!] Put ssh_lab_logs.txt in the same folder as this script, or edit LOG_FILE.")
        sys.exit(1)

def parse_failed_logins(lines: list[str]) -> dict:
    failed = {}  # ip -> {"count": int, "users": set()}
    for line in lines:
        if "Failed password" not in line:
            continue

        ip_match = IP_PATTERN.search(line)
        if not ip_match:
            continue
        ip = ip_match.group(0)

        user_match = USER_PATTERN.search(line)
        user = user_match.group(1) if user_match else "UNKNOWN"

        if ip not in failed:
            failed[ip] = {"count": 0, "users": set()}

        failed[ip]["count"] += 1
        failed[ip]["users"].add(user)

    return failed

def classify_attack(users: set[str]) -> str:
    # Simple heuristic:
    # - 1-2 users targeted: brute force
    # - many users targeted: password spray
    return "Brute force" if len(users) <= 2 else "Password spray"

def main():
    lines = load_lines(LOG_FILE)
    failed = parse_failed_logins(lines)

    if not failed:
        print("[i] No 'Failed password' events found in the log.")
        sys.exit(0)

    # Sort by highest failures
    sorted_items = sorted(failed.items(), key=lambda x: x[1]["count"], reverse=True)

    print("\n=== SSH Failed Login Summary (sorted) ===")
    for ip, data in sorted_items:
        users_sorted = ", ".join(sorted(data["users"]))
        attack_type = classify_attack(data["users"])
        print(f"{ip} -> {data['count']} failures | Users: {users_sorted} | Type: {attack_type}")

    print(f"\n=== Alerts (threshold > {ALERT_THRESHOLD}) ===")
    alerts_found = False
    for ip, data in sorted_items:
        if data["count"] > ALERT_THRESHOLD:
            users_sorted = ", ".join(sorted(data["users"]))
            attack_type = classify_attack(data["users"])
            print(f"ALERT ({attack_type}): {ip} -> {data['count']} failures | Users targeted: {users_sorted}")
            alerts_found = True

    if not alerts_found:
        print("No alerts triggered (try lowering ALERT_THRESHOLD).")

    # Save CSV report
    out_csv = "ssh_alerts.csv"
    with open(out_csv, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["ip", "failures", "unique_users", "users", "attack_type"])
        for ip, data in sorted_items:
            users_sorted = sorted(data["users"])
            writer.writerow([
                ip,
                data["count"],
                len(users_sorted),
                ";".join(users_sorted),
                classify_attack(data["users"]),
            ])

    print(f"\n[i] Saved CSV report: {out_csv}\n")

if __name__ == "__main__":
    main()

# output 
â”Œâ”€â”€(kaliã‰¿kali)-[~]
â””â”€$ python3 scirptU.py     

=== SSH Failed Login Summary (sorted) ===
192.168.74.134 -> 7 failures | Users: admin, user1, user2 | Type: Password spray

=== Alerts (threshold > 5) ===
ALERT (Password spray): 192.168.74.134 -> 7 failures | Users targeted: admin, user1, user2

[i] Saved CSV report: ssh_alerts.csv


#ðŸ§  Bonus (Optional but Good Practice)
chmod +x ssh_detector.py
./ssh_detector.py


--------------------------------------------------------------------------------------------------------------------------------------------------

# sending target machine 
scp /tmp/auth.log kali@192.168.74.134:/home/kali/ssh_lab_logs.txt
# getting from attacker machine 
scp ethan@192.168.74.133:/var/log/auth.log ~/ssh_lab_logs.txt

--------------------------------------------------------------------------------------------------------------------------------------------------


# 1ï¸âƒ£ COUNTING EVENTS (TOTAL COUNT)
count = 0

with open("ssh_lab_logs.txt") as f:
    for line in f:
        if "Failed password" in line:
            count += 1

print("Total failed logins:", count)


# 2ï¸âƒ£ COUNTING EVENTS BY KEY (MOST IMPORTANT)
failed_by_ip = {}

with open("ssh_lab_logs.txt") as f:
    for line in f:
        if "Failed password" in line:
            ip = extract_ip_somehow(line)

            if ip not in failed_by_ip:
                failed_by_ip[ip] = 0

            failed_by_ip[ip] += 1

# 3ï¸âƒ£ COUNTING UNIQUE THINGS (VERY IMPORTANT)
users = set()

with open("ssh_lab_logs.txt") as f:
    for line in f:
        if "Failed password" in line:
            user = extract_user(line)
            users.add(user)

print("Unique users targeted:", len(users))

# 4ï¸âƒ£ COUNTING MULTIPLE THINGS AT ONCE (REAL SOC LOGIC)
failed = {}

# Structure:
# failed[ip] = { "count": int, "users": set() }

with open("ssh_lab_logs.txt") as f:
    for line in f:
        if "Failed password" in line:
            ip = extract_ip(line)
            user = extract_user(line)

            if ip not in failed:
                failed[ip] = {"count": 0, "users": set()}

            failed[ip]["count"] += 1
            failed[ip]["users"].add(user)


# 5ï¸âƒ£ COUNTING EVENTS OVER TIME (SOC LEVEL-UP)
events_per_minute = {}

minute = timestamp[:16]  # "2025-12-22 07:10"

events_per_minute[minute] = events_per_minute.get(minute, 0) + 1

# 6ï¸âƒ£ COUNTING â€œSEEN BEFOREâ€ (REPEAT OFFENDER)
seen = {}

for alert in alerts:
    src = alert["src_ip"]
    seen[src] = seen.get(src, 0) + 1

# 7ï¸âƒ£ THE 5 COUNTING PATTERNS YOU MUST MASTER

1. Total count
count += 1

2. Count by key
d[key] = d.get(key, 0) + 1

3. Unique count
my_set.add(value)


4. Count + context
d[key]["count"] += 1
d[key]["users"].add(user)

5. Time-bucket count
bucket = timestamp[:16]
d[bucket] = d.get(bucket, 0) + 1

If you know these â†’ you can build almost any SOC detection.

--------------------------------------------------------------------------------------------------------------------------------------------------
# FULL TIME-BASED PASSWORD SPRAY SCRIPT

#!/usr/bin/env python3
import re
from datetime import datetime

LOG_FILE = "ssh_lab_logs.txt"

WINDOW_MINUTES = 5
USER_THRESHOLD = 5  # number of unique users to trigger alert

ip_pattern = re.compile(r"\b\d{1,3}(?:\.\d{1,3}){3}\b")
time_pattern = re.compile(r"\b[A-Z][a-z]{2}\s+\d+\s+\d{2}:\d{2}:\d{2}\b")
user_pattern = re.compile(r"Failed password for (?:invalid user )?([a-zA-Z0-9._-]+)")

def parse_time(ts: str) -> datetime:
    # SSH logs donâ€™t include year â†’ assume current year (fine for lab)
    return datetime.strptime(ts, "%b %d %H:%M:%S")

# (ip, time_bucket) -> set(users)
buckets = {}

with open(LOG_FILE, "r", encoding="utf-8", errors="replace") as f:
    for line in f:
        if "Failed password" not in line:
            continue

        ip_match = ip_pattern.search(line)
        time_match = time_pattern.search(line)
        user_match = user_pattern.search(line)

        if not ip_match or not time_match or not user_match:
            continue

        ip = ip_match.group()
        user = user_match.group(1)
        ts = parse_time(time_match.group())

        # Create 5-minute time bucket
        bucket_minute = (ts.minute // WINDOW_MINUTES) * WINDOW_MINUTES
        bucket_time = ts.replace(minute=bucket_minute, second=0)

        key = (ip, bucket_time)

        if key not in buckets:
            buckets[key] = set()

        buckets[key].add(user)

# ðŸ”” ALERT LOGIC
print("\n=== Password Spray Detection ===")
alerts = 0

for (ip, bucket_time), users in buckets.items():
    if len(users) >= USER_THRESHOLD:
        alerts += 1
        users_list = ", ".join(sorted(users))
        print(
            f"ALERT: Password spray detected\n"
            f"  Source IP : {ip}\n"
            f"  Time      : {bucket_time.strftime('%H:%M')} â€“ "
            f"{(bucket_time.minute + WINDOW_MINUTES) % 60:02d}\n"
            f"  Users     : {users_list}\n"
            f"  Count     : {len(users)}\n"
        )

if alerts == 0:
    print("No password spray activity detected.")

